\chapter{User Interface (UI) \label{interface}}

Users interact with the Aspen web server through four mechanisms: a filesystem
directory structure, command line arguments and options, configuration files,
and the environment. Where a given program parameter is set in more than one of
these contexts, they take precedence in the order given here. For example, a
\var{mode} option on the command line will override any \var{mode} setting in a
config file or in the environment.


\section{Directory Structure \label{directory-structure}}

An \dfn{Aspen website} is, in respect of your filesystem, a directory on that
filesystem (in respect of the World Wide Web, an Aspen website is the website as
experienced through the Web). An Aspen website has a certain filesystem layout,
the specifics of which depend on the type of website you are building (recall
the discussion of types of website in the
\ulink{Introduction}{./introduction.html}).

You will find API at \ulink{aspen.paths}{./api-paths.html} for accessing certain
standard filesystem paths at and under your Aspen website.


\subsection{Application Websites} \label{directories-application}

If you are building an \var{application} website, then Aspen expects the
following directory structure underneath your website's root directory on the
filesystem:

\begin{verbatim}
etc/
lib/python/
\end{verbatim}

Any of Aspen's \ulink{configuration files}{./config-files.html} are located in
\file{etc}. Website-specific Python modules and packages are stored in
\file{lib/python}, and Aspen adds this directory to \var{sys.path} (as well as
\file{lib/python/site-packages}, if that exists). You are free to add to this
directory structure. For example, you might choose to store data files for your
website in a \file{var} directory, or you might store helper scripts associated
with your website in a \file{bin} directory. As you may recognize, an Aspen
application-website directory is patterned after the traditional \UNIX{} layout.
Aspen comes with a tool, \ulink{\program{workingenv}}{./workingenv.html}, which
aids development and deployment by turning this userland into an isolated
sandbox.

Aspen decides to serve your website as an application based on the existence of
a file at \file{etc/aspen.conf}. Without that file, Aspen will serve your
website as a publication/hybrid website, and as a result the \file{etc}
directory is also a requirement for application websites.  The \file{lib/python}
directory, on the other hand, is not required, and you may choose to install
some or all of your site-specific Python libraries anywhere on
\envvar{PYTHONPATH}.


\subsection{Publication and Hybrid Websites} \label{directories-pub-hybrid}

For \var{publication} and \var{hybrid} websites, Aspen uses your operating
system's filesystem to model the hierarchical organization of your site. In this
case, URLs map literally to your website's root directory. Aspen therefore takes
the directories which under a pure application website would be directly under
your root directory---takes and puts them in a so-called \dfn{junk drawer}
directory named \file{__} (that's two underscores). So here would be a minimal
publication/hybrid directory layout (also showing a common homepage file):

\begin{verbatim}
__/etc/
__/lib/python/
index.html
\end{verbatim}

The existence and contents of the junk drawer are hidden from prying eyes,
because Aspen will respond to any requests mapping at or below the junk drawer
with a \ulink{\code{404 Not
Found}}{http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.5}.

Aspen serves any website that has neither junk drawer nor \file{etc/aspen.conf}
file as an unconfigured publication website.


\section{Command Line \label{command-line}}

Usage:

\begin{verbatim}
aspen [options] [command]
\end{verbatim}

Aspen takes one optional positional argument, \var{command}, which must be one
of: \code{start}, \code{status}, \code{stop}, \code{restart}, or \code{runfg}.
The default is \code{runfg}, which causes Aspen to run in the foreground,
sending all messages to stdout.

\code{start}, \code{status}, \code{stop}, and \code{restart} control Aspen as a
daemon via a pidfile. If the website is an application or has a junk drawer,
then the pidfile is at \file{var/aspen.pid} or \file{__/var/aspen.pid},
respectively; otherwise, the pidfile is created in \file{/tmp}. Likewise, stdout
and stderr are redirected to \file{var/aspen.log} or \file{__/var/aspen.log},
respectively, or to \file{/dev/null}. The \file{var} directory will be created
if it does not exist. The permission mode of the pidfile is set to \code{0600},
as is that of the log file if it is not \file{/dev/null}.

The Aspen distribution includes a script in \file{etc/aspen_bash_completion}
that can be used to configure the bash shell to autocomplete from among Aspen's
arguments. See the source for more information.

Aspen's command-line options are as follows:
% a subset of the options available in the config file:

\begin{tableiii}{l|l|l}{var}{Option}{Description}{Default}

\lineiii{\programopt{-a}/\longprogramopt{-address}=\var{address}}
    {The address to which Aspen should bind. If \var{address} begins with a dot
    or a forward slash, then it is interpreted as an AF_UNIX socket. If it
    contains more than one colon, it is seen as an AF_INET6 address. Otherwise,
    it is interpreted as AF_INET. If \var{address} begins with a colon, the IP
    address defaults to \code{0.0.0.0}.} {\code{0.0.0.0:8080}}

% \lineiii{\programopt{-l}/\longprogramopt{-log_filter}=\var{log_filter}}
%     {A subsystem filter to apply to the error log, per the logging module.}
%     {\code{}}

\lineiii{\programopt{-m}/\longprogramopt{-mode}=\var{mode}}
    {One of \code{debugging}, \code{development}, \code{staging}, or
    \code{production}. In debugging and development modes, Aspen will restart
    itself any time configuration files or module source files change on the
    filesystem.}
    {\code{development}}

\lineiii{\programopt{-r}/\longprogramopt{-root}=\var{root}}
    {The directory containing the website for Aspen to serve.}
    {\code{.}}

% \lineiii{\programopt{-v}/\longprogramopt{-log_level}=\var{log_level}}
%     {The error log level. Valid options per the logging module
%     are (case-insensitive): \code{notset}, \code{debug}, \code{info},
%     \code{warning}, \code{error}, \code{critical}.}{\code{warning}}

\end{tableiii}

\section{Configuration Files \label{config-files}}

Aspen obeys several configuration files, all located in \file{etc} (for
application websites, that is; for publication/hybrid sites with a junk drawer,
substitute \file{__/etc} here and passim). The comment character for these files
is \#, and comments can be included in-line. Blank lines are ignored, as is
initial and trailing whitespace per-line. Where section names are called for,
they are given in brackets.

Where a configuration file calls for a Python object to be specified, this is
done in a notation derived from setuptools' \var{entry_points} feature: a dotted
module name, followed by a colon and a dotted identifier naming an object within
the module. This is referred to below as \dfn{colon notation}. The following
example would import the \code{bar} object from \code{example.package.foo}, and
use its \code{baz} attribute:

\begin{verbatim}
example.package.foo:bar.baz
\end{verbatim}




\subsection{apps.conf}
\label{apps-conf}

In Aspen, an \dfn{application} or \dfn{app} refers to a WSGI application that is
mounted on a particular filesystem directory. Apps are set up in
\file{__/etc/apps.conf}.

The \file{__/etc/apps.conf} file contains a newline-separated list of
white-space-separated path name/object name pairs. The path names refer to
URL-space, and are translated literally to the filesystem. If the trailing slash
is given, then requests for that directory will first be redirected to the
trailing slash before being handed off to the application. If no trailing slash
is given, the application will also get requests without the slash. When
choosing an application to service a request, the most specific pathname matches
first.

Object names are in colon notation, and they name WSGI callables. Aspen updates
the \code{SCRIPT_NAME} and \code{PATH_INFO} settings in \code{environ} before
handing off to the relevant callable. \code{SCRIPT_NAME} will never end with a
slash, and if \code{PATH_INFO} is not empty, it will always begin with a slash.

Aspen will (over)write a file called \file{README.aspen} in each directory
mentioned in \file{apps.conf}, containing the relevant line from
\file{apps.conf}. If the directory does not exist, it is created. Aspen will
also remove any obsolete \file{README.aspen} files within your site tree.


\subsubsection{Example apps.conf}

\begin{verbatim}
/foo        example.apps:foo    # will get both /foo and /foo/
/bar/       example.apps:bar    # /bar will redirect to /bar/
/bar/baz    example.apps:baz    # will 'steal' some of /bar's requests
\end{verbatim}


\subsection{aspen.conf}
\label{aspen-conf}

Aspen's general configuration file is at \file{__/etc/aspen.conf}. It is in
\file{.ini}-style format per the \module{ConfigParser} module. Aspen responds to
the following settings in the \code{main} section. You may define additional
settings and sections that are meaningful to your application, which you may
access using the \class{aspen.conf} object described below in the "API" chapter.

% There are five sections recognized: \code{DEFAULT},
% \code{debugging}, \code{development}, \code{staging}, and \code{production}. Any
% of the below settings can be given in any section, except for \var{mode}, which
% can only occur in \code{DEFAULT}. However, only two sections will be used at any
% given time: \code{DEFAULT}, and the section corresponding to the current
% deployment mode (see The Environment for more on mode).

\begin{tableiii}{l|l|l}{var}{Option}{Description}{Default}

\lineiii{address}{The address to which Aspen should bind. If \var{address}
begins with a dot or a forward slash, then it is interpreted as an AF_UNIX
socket. If it contains more than one colon, it is seen as an AF_INET6 address.
Otherwise, it is interpreted as AF_INET. If \var{address} begins with a colon,
the IP address defaults to \code{0.0.0.0}.}{\code{0.0.0.0:8080}}

\lineiii{defaults}{A comma-separated list of names to look for when a directory
is requested. Any default resource is located immediately before dispatching to
a handler.}{\code{index.html, index.htm}}

\lineiii{http_version}{The version of HTTP to speak, either \code{1.0} or
\code{1.1}.}{\code{1.1}}

% \lineiii{group}{A groupname or gid to which, if given, Aspen will attempt to
% switch after binding to the socket.}{}
%
% \lineiii{log_access}{Whether or not to maintain an access log. Valid options
% are (case-insensitive): \code{yes}, \code{no}, \code{none}, \code{true},
% \code{false}, \code{0}, \code{1}. The access log will be in Apache's Combined
% Log Format.}{\code{no}}
%
% \lineiii{log_format}{The format of error log messages, per the logging
% module.}{\code{\%(levelname)s:\%(name)s:\%(message)s}}
%
% \lineiii{log_level}{The error log level. Valid options per the logging module
% are (case-insensitive): \code{notset}, \code{debug}, \code{info},
% \code{warning}, \code{error}, \code{critical}.}{\code{warning}}
%
% \lineiii{log_filter}{A subsystem filter to apply to the error log, per the
% logging module.}{}

\lineiii{mode}{One of \code{debugging}, \code{development}, \code{staging}, or
\code{production}. In debugging and development modes, Aspen will restart itself
any time configuration files or module source files change on the
filesystem.}{\code{development}}
% (Naturally, this option only obtains in the DEFAULT section.)

\lineiii{threads}{The number of threads to maintain in the request-servicing
thread pool.}{\code{10}}

% \lineiii{user}{A username or uid to which, if given, Aspen will attempt to
% switch after binding to the socket.}{}
%
\end{tableiii}

\subsubsection{Example}

Here is an example \file{aspen.conf} configuration file:

\begin{verbatim}
[main]
address = :8000

[myapp]
knob = true
\end{verbatim}


\subsection{handlers.conf}
\label{handlers-conf}

Aspen \dfn{handlers} are WSGI applications that are associated with files and
directories on the filesystem according to arbitrary rules. This provides a
flexible infrastructure for many different software engineering patterns.

The \file{__/etc/handlers.conf} file begins with an anonymous "rules" section,
which is a newline-separated list of white-space-separated rule name/object name
pairs. Rule names can be any string without whitespace. Each object name (in
colon notation) specifies a \dfn{rule}, a callable taking a filesystem path name
and an arbitrary predicate string, and returning \class{True} or \class{False}.
The path argument is absolute and is guaranteed to exist; it is
\envvar{PATH_TRANSLATED} from the WSGI environment, with any default resource
already located.

Following the rule specification are sections specifying \dfn{handlers}, which
as mentioned above are WSGI callables.

The name of each section specifies a handler (a WSGI callable) in colon
notation. The body of each section is a newline-separated list of conditions
under which this handler is to be called. Fundamentally, these conditions are
made up of a rule name as defined at the beginning of the file, and an arbitrary
predicate string (which can include whitespace) that is meaningful to the
matching rule callable. If no predicate is given, then the rule callable will
receive \class{None} for its predicate argument. Rules must be explicitly
specified at the beginning of the file before being available within handler
sections. After the first condition in a handler section, additional condition
lines must begin with one of \code{AND}, \code{OR}, or \code{NOT}. These
case-insensitive tokens specify how conditions are to be combined in evaluating
whether to use this handler.

On each request, handlers are considered in the order given, and the first
matching handler is used. Only one handler is used for any given request.

Note that if the file \file{__/etc/handlers.conf} exists at all, the defaults
(see the example below) disappear, and you must respecify any of the default
rules in your own file if you want them.


\subsubsection{Example handlers.conf}
This is Aspen's default handler configuration:

\begin{verbatim}
catch_all   aspen.rules:catch_all

[aspen.handlers.static:wsgi]
  catch_all
\end{verbatim}


Here is a more full-featured example:

\begin{verbatim}
catch_all   aspen.rules:catch_all
isfile      aspen.rules:isfile
fnmatch     aspen.rules:fnmatch


# Set up scripts.
# ===============

[aspen.handlers.pyscript:wsgi]
    isfile
AND fnmatch *.py


# Everything else is served statically.
# =====================================

[aspen.handlers.static:wsgi]
  catch_all
\end{verbatim}

\subsection{middleware.conf}
\label{middleware-conf}

Aspen allows for a full WSGI middleware stack, configured via the
\file{__/etc/middleware.conf} file. This is simply a newline-separated list of
middleware factories in colon notation. Each factory (which may be a class
constructor or other callable) is called with exactly one positional argument,
the next middleware on the stack. The first-mentioned middleware will therefore
be the top-most on the stack (i.e., closest to the browser).


\subsubsection{Example middleware.conf}

\begin{verbatim}
example.foo:bar # closest to browser
example.baz:buz # closest to your apps/handlers
\end{verbatim}


\section{The Environment}
\label{environment}

Aspen incorporates a \module{mode} module, which uses the \envvar{PYTHONMODE}
environment variable to model the application life-cycle through four deployment
modes: \code{debugging}, \code{development}, \code{staging}, and
\code{production}. This module is available to your applications at
\module{aspen.mode}, and its API is documented in the "API" chapter, below.

Aspen itself adapts to the current \envvar{PYTHONMODE}. In debugging and
development modes, Aspen will restart itself any time a configuration file or
module source file changes on the filesystem.
