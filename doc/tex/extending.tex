\chapter{Extending Aspen \label{extending}}

Aspen uses Python's WSGI specification for its extension architecture. There are
three categories of extension:

\begin{tableii}{l|l}{}{Category}{Explanation}
\lineii{applications}{applications are connected to directories within the site
    hierarchy; only one app touches any given request}
\lineii{handlers}{handlers are tied to individual resources (i.e., files and
    directories) based on extensible rules; only one handler touches any given
    request}
\lineii{middleware}{one or many middleware applications may be specified;
    all middleware generally touches every request}
\end{tableii}

All extensions are WSGI callables, connected to the above entry points with
three configuration files in \file{__/etc}:

\begin{itemize}
\item{\file{apps.conf}}
\item{\file{handlers.conf}}
\item{\file{middleware.conf}}
\end{itemize}

Where called for in these files, objects are specified in a notation derived
from setuptools' entry_points feature: a dotted module name, followed by a colon
and a dotted identifier naming an object within the module. This is referred to
below as \dfn{colon notation}. The following example would import the \code{bar}
object from \code{example.package.foo}, and use its \code{baz} attribute (a WSGI
callable):

\begin{verbatim}
example.package.foo:bar.baz
\end{verbatim}

The comment character for these files is \#, and comments can be included
in-line. Blank lines are ignored, as is initial and trailing whitespace
per-line. Where section names are called for, they are given in brackets.


\section{Applications: Path-based Extension \label{apps}}

In Aspen, an \dfn{application} or \dfn{app} refers to a WSGI application that is
connected to a particular directory. Apps are set up in \file{__/etc/apps.conf}.

The \file{__/etc/apps.conf} file contains a newline-separated list of
white-space-separated path name/object name pairs. The path names refer to
URL-space, and are translated literally to the filesystem. If the trailing slash
is given, then requests for that directory will first be redirected to the
trailing slash before being handed off to the application. If no trailing slash
is given, the application will also get requests without the slash. When
choosing an application to service a request, the most specific pathname matches
first.

Object names are in colon notation, and they name WSGI callables. Aspen updates
the \code{PATH_INFO} and \code{SCRIPT_NAME} settings in \code{environ} before
handing off to the relevant callable. Any trailing slash will be included in
\code{PATH_INFO}, not in \code{SCRIPT_NAME}.

Aspen will (over)write a file called \file{README.aspen} in each directory
mentioned in \file{apps.conf}, containing the relevant line from
\file{apps.conf}. If the directory does not exist, it is created. Aspen will
also remove any obsolete \file{README.aspen} files within your site tree.


\subsection{Example apps.conf}

\begin{verbatim}
/foo        example.apps:foo    # will get both /foo and /foo/
/bar/       example.apps:bar    # /bar will redirect to /bar/
/bar/baz    example.apps:baz    # will 'steal' some of /bar's requests
\end{verbatim}


\section{Handlers: Resource-based Extension \label{handlers}}

Aspen \dfn{handlers} are WSGI applications that are associated with files and
directories on the filesystem according to arbitrary rules. This provides a
flexible infrastructure for many different development patterns.

The \file{__/etc/handlers.conf} file begins with an anonymous "rules" section,
which is a newline-separated list of white-space-separated rule name/object name
pairs. Rule names can be any string without whitespace. Each object name (in
colon notation) specifies a \dfn{rule}, a callable taking a filesystem path name
and an arbitrary predicate string, and returning \class{True} or \class{False}.

Following the rule specification are sections specifying \dfn{handlers}, which
as mentioned above are WSGI callables.

The name of each section specifies a handler (a WSGI callable) in colon
notation. The body of each section is a newline-separated list of conditions
under which this handler is to be called. Fundamentally, these conditions are
made up of a rule name as defined at the beginning of the file, and an arbitrary
predicate string (which can include whitespace) that is meaningful to the
matching rule callable. If no predicate is given, then the rule callable will
receive \class{None} for its predicate argument. Rules must be explicitly
specified at the beginning of the file before being available within handler
sections. After the first condition in a handler section, additional condition
lines must begin with one of \code{AND}, \code{OR}, or \code{NOT}. These
case-insensitive tokens specify how conditions are to be combined in evaluating
whether to use this handler.

On each request, handlers are considered in the order given, and the first
matching handler is used. Only one handler is used for any given request.

Note that if the file \file{__/etc/handlers.conf} exists at all, the defaults
(see the example below) disappear, and you must respecify any of the default
rules in your own file if you want them.


\subsection{Example handlers.conf}
This is Aspen's default handler configuration:

\begin{verbatim}
catch_all   aspen.rules:catch_all
isdir       aspen.rules:isdir


[aspen.handlers.autoindex:autoindex]
  isdir                         # directories get an automatic index

[aspen.handlers.static:static]
  catch_all                     # anything else, serve it statically
\end{verbatim}


\section{Middleware: Global Extension \label{middleware}}

Aspen allows for a full WSGI middleware stack, configured via the
\file{__/etc/middleware.conf} file. This is simply a newline-separated list of
middleware factories in colon notation. Each factory (which may be a class
constructor or other callable) is called with exactly one positional argument,
the next middleware on the stack. The first-mentioned middleware will therefore
be the outer-most in the stack (i.e., closest to the browser).


\subsection{Example middleware.conf}

\begin{verbatim}
example.foo:bar # closest to browser
example.baz:buz # closest to your apps/handlers
\end{verbatim}